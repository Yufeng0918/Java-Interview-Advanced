# 生产实践



## 1. CPU负载过高

其实核心思路，就是找到这台服务器上，是哪个进程的哪个线程的哪段代码，导致cpu 100了，主要就是考察你是否熟练运用一些线上的命令。线上的经验，就是之前有一个bug，是一个很年轻的同学写的，就是我们当时是定了异常日志是写到es里去的

```java
public void log(String message) {
	try {
		// 往es去写
	} catch(Exception e) {
		// 递归死循环代码
		log(message);
	}
}
```

线上事故，es集群出了点问题，没法写，最后出现线上几十台机器，全部因为这一行代码，全体cpu 100%，卡死了

**定位耗费cpu的进程**

```shell
top -c，就可以显示进程列表，然后输入P，按照cpu使用率排序，你会看到类似下面的东西
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
43987 root 20 0 28.2g 4.5g 68m S 99.0 24.0 44333.4 java -Xms。。。
```

大概类似上面这样，能看到哪个进程，CPU负载最高，还有启动这个进程的命令，比如一般就是java啥啥的。

**定位耗费cpu的线程**

```shell
top -Hp 43987
16872 //线程id
```

就是输入那个进程id就好了，然后输入P，按照cpu使用率排序，你会看到类似下面的东西

大概类似上面那样，你就可以看到这个进程里的哪个线程耗费cpu最高

**定位哪段代码导致的cpu过高**

```shell
printf “%x\\n” 16872，把线程pid转换成16进制，比如41e8
jstack 43987 | grep ‘0x41e8’ -C5 --color
```

这个就是用**jstack打印进程的堆栈信息**，而且通过grep那个线程的16进制的pid，找到那个线程相关的东西，这个时候就可以在打印出的代码里，看到是**哪个类的哪个方法**导致的这个cpu 100%的问题



## 2. Kill不了线程

当时那个发布系统，他自己在每台机器上有一个进程，发布和启动的时候，他启动的那个进程，不是直接java -jar来启动的，发布系统的一个进程搞了一个子进程，子进程是我们的系统进程。

这个其实就是线上可能遇到的一个问题，我们之前确实就是遇到过这个问题，

- kill一个进程死活杀不死，那个进程成了僵尸进程，就是zombie状态。
- 这是因为这个进程释放了资源，但是没有得到父进程的确认。
- ps aux，看看STAT那一栏，如果是Z，那么就是zombie状态的僵尸进程
- ps -ef | grep 僵尸进程id，可以找到父进程id
- 然后先kill掉父进程即可



## 3. 磁盘空间不够

```shell
df -h
```

先看看磁盘使用的情况。 然后就是到你的系统部署的地方，一般就是tomcat下的日志、spring boot的日志，去看看，如果过多，就删除掉一些日志就行了，自己注意让tomcat或者nginx之类的日志输出，按天切割，这样你还可以写个shell脚本，crontab定时，定期删除7天以前的日志

要是不行，那就：find / -size +100M |xargs ls -lh，找找大于100m的文件，但是如果有大量的小文件，那么这样是不行的

或者是用：

```shell
du -h >fs_du.log
```

看看各个目录占用的磁盘空间大小，看看是不是哪个目录有大量的小文件

